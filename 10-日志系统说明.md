# 📝 Weiqi-Go 结构化日志系统说明

## 概述

Weiqi-Go 使用 Go 标准库的 `log/slog` 包实现结构化日志，提供强大的日志记录、追踪和分析能力。

---

## 🎯 核心特性

### 1. 结构化日志
- 使用键值对记录日志，易于解析和分析
- 支持 JSON 和文本两种格式
- 自动添加时间戳、日志级别等元数据

### 2. 请求追踪
- 每个 HTTP 请求自动生成唯一的 Request ID
- Request ID 贯穿整个请求生命周期
- 便于追踪和调试

### 3. 日志级别
- **Debug**: 详细的调试信息
- **Info**: 一般信息（默认）
- **Warn**: 警告信息
- **Error**: 错误信息

### 4. 自动记录
- HTTP 请求自动记录
- 请求耗时自动计算
- 错误自动捕获

---

## ⚙️ 配置

### 环境变量

在 `.env` 文件中配置：

```bash
# 日志级别：debug, info, warn, error
LOG_LEVEL=info

# 日志格式：true=JSON, false=文本
LOG_JSON=false
```

### 配置示例

#### 开发环境（文本格式，详细日志）
```bash
LOG_LEVEL=debug
LOG_JSON=false
```

#### 生产环境（JSON 格式，标准日志）
```bash
LOG_LEVEL=info
LOG_JSON=true
```

#### 问题排查（详细 JSON 日志）
```bash
LOG_LEVEL=debug
LOG_JSON=true
```

---

## 📊 日志格式

### 文本格式示例

```
time=2025-12-03T17:14:23.456+08:00 level=INFO msg="application starting" version=1.0.0 log_level=info log_format=text
time=2025-12-03T17:14:23.789+08:00 level=INFO msg="connecting to database" uri=mongodb://localhost:27017
time=2025-12-03T17:14:24.123+08:00 level=INFO msg="database connected successfully"
time=2025-12-03T17:14:24.234+08:00 level=INFO msg="request started" request_id=20251203171424-abc12345 method=POST path=/v1/auth/login ip=127.0.0.1
time=2025-12-03T17:14:24.345+08:00 level=INFO msg="request completed" request_id=20251203171424-abc12345 method=POST path=/v1/auth/login status=200 duration_ms=111
```

### JSON 格式示例

```json
{"time":"2025-12-03T17:14:23.456+08:00","level":"INFO","msg":"application starting","version":"1.0.0","log_level":"info","log_format":"json"}
{"time":"2025-12-03T17:14:23.789+08:00","level":"INFO","msg":"connecting to database","uri":"mongodb://localhost:27017"}
{"time":"2025-12-03T17:14:24.123+08:00","level":"INFO","msg":"database connected successfully"}
{"time":"2025-12-03T17:14:24.234+08:00","level":"INFO","msg":"request started","request_id":"20251203171424-abc12345","method":"POST","path":"/v1/auth/login","ip":"127.0.0.1","user_agent":"curl/7.68.0"}
{"time":"2025-12-03T17:14:24.345+08:00","level":"INFO","msg":"request completed","request_id":"20251203171424-abc12345","method":"POST","path":"/v1/auth/login","status":200,"duration_ms":111}
```

---

## 🔍 日志字段说明

### 通用字段
- `time`: 时间戳（ISO 8601 格式）
- `level`: 日志级别（DEBUG/INFO/WARN/ERROR）
- `msg`: 日志消息

### HTTP 请求字段
- `request_id`: 请求唯一标识符
- `method`: HTTP 方法（GET/POST/PUT/DELETE）
- `path`: 请求路径
- `query`: 查询参数
- `status`: HTTP 状态码
- `duration_ms`: 请求耗时（毫秒）
- `ip`: 客户端 IP
- `user_agent`: 客户端 User-Agent

### 应用字段
- `version`: 应用版本
- `log_level`: 当前日志级别
- `log_format`: 日志格式（json/text）
- `uri`: 数据库连接 URI
- `url`: AI 服务 URL
- `error`: 错误信息

---

## 💻 代码使用

### 基础日志记录

```go
import "github.com/nankp236270/weiqi-go/logger"

// 记录 Info 日志
logger.Info("user logged in", 
    "user_id", "12345",
    "username", "alice",
)

// 记录 Error 日志
logger.Error("database connection failed",
    "error", err,
    "retry_count", 3,
)

// 记录 Debug 日志
logger.Debug("processing request",
    "step", "validation",
    "data_size", 1024,
)

// 记录 Warn 日志
logger.Warn("slow query detected",
    "query_time_ms", 1500,
    "threshold_ms", 1000,
)
```

### 带上下文的日志

```go
import (
    "context"
    "github.com/nankp236270/weiqi-go/logger"
)

func handleRequest(ctx context.Context) {
    // 自动包含 request_id
    logger.InfoContext(ctx, "processing game move",
        "game_id", "abc123",
        "player", "alice",
        "position", "D4",
    )
    
    logger.ErrorContext(ctx, "invalid move",
        "error", "point not empty",
        "position", "D4",
    )
}
```

### Gin 中间件（自动集成）

```go
import (
    "github.com/gin-gonic/gin"
    "github.com/nankp236270/weiqi-go/logger"
)

func setupRouter() *gin.Engine {
    router := gin.New()
    
    // 添加恢复中间件
    router.Use(gin.Recovery())
    
    // 添加日志中间件（自动记录所有请求）
    router.Use(logger.RequestLoggerMiddleware())
    
    // ... 注册路由
    
    return router
}
```

---

## 📈 日志分析

### 使用 jq 分析 JSON 日志

```bash
# 查看所有错误日志
cat logs.json | jq 'select(.level == "ERROR")'

# 统计请求耗时
cat logs.json | jq 'select(.duration_ms) | .duration_ms' | awk '{sum+=$1; count++} END {print "平均耗时:", sum/count, "ms"}'

# 查看特定 Request ID 的所有日志
cat logs.json | jq 'select(.request_id == "20251203171424-abc12345")'

# 统计各 API 的调用次数
cat logs.json | jq -r 'select(.path) | .path' | sort | uniq -c | sort -rn

# 查看慢请求（>1000ms）
cat logs.json | jq 'select(.duration_ms > 1000)'

# 按状态码统计
cat logs.json | jq -r 'select(.status) | .status' | sort | uniq -c
```

### 使用 grep 分析文本日志

```bash
# 查看所有错误
grep "level=ERROR" logs.txt

# 查看特定用户的操作
grep "user_id=12345" logs.txt

# 查看慢请求
grep "duration_ms" logs.txt | awk '$NF > 1000'

# 统计请求数
grep "request completed" logs.txt | wc -l
```

---

## 🎯 最佳实践

### 1. 日志级别选择

```go
// ✅ 正确：使用合适的日志级别
logger.Debug("cache hit", "key", key)                    // 调试信息
logger.Info("user registered", "user_id", userID)        // 重要事件
logger.Warn("rate limit approaching", "usage", "90%")    // 警告
logger.Error("payment failed", "error", err)             // 错误

// ❌ 错误：滥用日志级别
logger.Error("user clicked button")  // 这应该是 Debug
logger.Info("database crashed")      // 这应该是 Error
```

### 2. 结构化字段

```go
// ✅ 正确：使用键值对
logger.Info("game created",
    "game_id", gameID,
    "player_black", blackID,
    "player_white", whiteID,
    "board_size", 19,
)

// ❌ 错误：使用字符串拼接
logger.Info(fmt.Sprintf("game %s created by %s and %s", gameID, blackID, whiteID))
```

### 3. 敏感信息

```go
// ✅ 正确：不记录敏感信息
logger.Info("user logged in",
    "user_id", userID,
    "username", username,
)

// ❌ 错误：记录密码、Token 等敏感信息
logger.Info("user logged in",
    "password", password,      // 危险！
    "token", token,            // 危险！
)
```

### 4. 错误处理

```go
// ✅ 正确：记录完整的错误上下文
if err := db.Save(game); err != nil {
    logger.Error("failed to save game",
        "error", err,
        "game_id", game.ID,
        "operation", "save",
    )
    return err
}

// ❌ 错误：只记录错误消息
if err != nil {
    logger.Error("error occurred")  // 缺少上下文
    return err
}
```

### 5. 性能考虑

```go
// ✅ 正确：避免在循环中记录大量日志
logger.Debug("processing batch", "size", len(items))
for _, item := range items {
    // 只在出错时记录
    if err := process(item); err != nil {
        logger.Error("failed to process item",
            "item_id", item.ID,
            "error", err,
        )
    }
}
logger.Info("batch completed", "processed", len(items))

// ❌ 错误：在循环中记录每个操作
for _, item := range items {
    logger.Info("processing item", "item_id", item.ID)  // 性能问题
    process(item)
}
```

---

## 🔧 故障排查

### 查看实时日志

```bash
# Docker 环境
docker compose logs -f weiqi-backend

# 本地运行
./weiqi-go-server | tee logs.txt
```

### 追踪特定请求

1. 从响应头或日志中获取 Request ID
2. 使用 Request ID 过滤日志

```bash
# JSON 格式
cat logs.json | jq 'select(.request_id == "20251203171424-abc12345")'

# 文本格式
grep "request_id=20251203171424-abc12345" logs.txt
```

### 分析性能问题

```bash
# 查看慢请求
cat logs.json | jq 'select(.duration_ms > 1000) | {path, duration_ms, status}'

# 统计平均响应时间
cat logs.json | jq -r 'select(.duration_ms) | "\(.path) \(.duration_ms)"' | \
    awk '{sum[$1]+=$2; count[$1]++} END {for(path in sum) print path, sum[path]/count[path]}'
```

### 查找错误

```bash
# 查看所有错误
cat logs.json | jq 'select(.level == "ERROR")'

# 统计错误类型
cat logs.json | jq -r 'select(.level == "ERROR") | .msg' | sort | uniq -c | sort -rn

# 查看特定时间段的错误
cat logs.json | jq 'select(.level == "ERROR" and .time >= "2025-12-03T17:00:00")'
```

---

## 📊 监控集成

### 日志聚合工具

结构化日志可以轻松集成到各种日志聚合工具：

1. **ELK Stack** (Elasticsearch + Logstash + Kibana)
   - 使用 JSON 格式
   - 配置 Logstash 解析日志
   - 在 Kibana 中创建仪表板

2. **Grafana Loki**
   - 轻量级日志聚合
   - 与 Prometheus 集成
   - 支持 LogQL 查询

3. **Datadog**
   - 云原生监控平台
   - 自动解析 JSON 日志
   - 实时告警

4. **CloudWatch** (AWS)
   - AWS 原生日志服务
   - 自动收集容器日志
   - 与 Lambda 集成

### 配置示例（ELK）

```yaml
# logstash.conf
input {
  file {
    path => "/var/log/weiqi-go/*.json"
    codec => "json"
  }
}

filter {
  if [level] == "ERROR" {
    mutate {
      add_tag => ["error"]
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "weiqi-go-%{+YYYY.MM.dd}"
  }
}
```

---

## 🎓 总结

### 优势
- ✅ 结构化，易于解析和分析
- ✅ Request ID 追踪，便于调试
- ✅ 多级别，灵活控制详细程度
- ✅ 自动记录 HTTP 请求
- ✅ 支持 JSON 和文本格式
- ✅ 易于集成监控工具

### 使用建议
1. 开发环境使用文本格式 + Debug 级别
2. 生产环境使用 JSON 格式 + Info 级别
3. 问题排查时临时提升到 Debug 级别
4. 定期分析日志，优化性能
5. 使用 Request ID 追踪完整请求链路

---

**日志系统版本**: 1.0.0  
**最后更新**: 2025年12月3日

