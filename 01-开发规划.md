### **完整开发路线图**

#### **阶段 0: 基础 - “单一事实来源”框架**
这是最关键的新增步骤。在编写更多游戏逻辑之前，我们先构建一个强制执行一致性的系统。

1.  **创建共享测试套件仓库**：
    *   创建一个**新的、独立的 Git 仓库**（例如 `weiqi-rules-test-suite`）。
    *   这个仓库里只包含 `JSON` 文件，每个文件代表一个特定的测试用例。
    *   **为什么要用独立的仓库？** 这样 `weiqi-go` 和 `weiqi-ai` 都可以将其作为 Git 子模块引入，或在各自的 CI/CD 流水线中克隆它，而不会混淆代码。

2.  **定义测试用例的 JSON 结构 (Schema)**：
    *   每个 JSON 文件将描述一个场景。例如，`capture_one_stone.json`：
    ```json
    {
      "description": "一个简单的提掉单颗棋子的案例。",
      "initial_board": [
        // 代表落子前棋盘状态的 19x19 数组
      ],
      "move": {
        "player": "black", // 下棋的玩家 (1 代表黑, 2 代表白)
        "x": 1,
        "y": 1
      },
      "expected_board": [
        // 代表落子和提子后棋盘状态的 19x19 数组
      ],
      "expected_captures": 1,
      "is_legal": true
    }
    ```
    *   我们将为所有情况创建测试用例：基本落子、简单提子、提多子、自杀手（非法）、提子解围的自杀手（合法）、劫（Ko）和全局同形再现（Superko）。

#### **阶段 1: Go 后端 - 巩固游戏引擎**
现在，我们通过使用测试套件，使现有的 Go 代码完全符合 `RULES.md` 的规定。

1.  **集成测试套件**：
    *   将 `weiqi-rules-test-suite` 仓库作为子模块（submodule）添加到 `weiqi-go` 中。
    *   在 `game/board_test.go` 中，编写一个测试运行器函数。该函数将读取测试套件目录中所有的 `*.json` 文件，解析它们，使用你的 Go 游戏引擎执行所描述的着法，并断言（assert）最终的棋盘状态、提子数量和合法性与 JSON 文件中的 `expected` 值相匹配。

2.  **在 Go 中实现所有规则**：
    *   逐节阅读 `RULES.md` 并实现。
    *   **`3.2. 提子 (Capture)`**：确保你的提子逻辑是稳健的。
    *   **`3.3.1. 自杀禁令 (No Suicide)`**：实现对自提的检查，包括该着法能提掉对方棋子的例外情况。
    *   **`3.3.2. 全局同形再现禁令 (Positional Superko)`**：这至关重要。在 `game/game.go` 的 `Game` 结构体中，你必须添加一个棋盘状态的历史记录（例如 `history map[string]bool`）。每次落子后，存储新棋盘状态的唯一表示（哈希或字符串）。在落子前，检查 resultante 的状态是否已存在于历史记录中。

3.  **此阶段目标**：Go 游戏引擎必须 100% 通过共享测试套件中的所有测试。

#### **阶段 2: Python AI 服务 - 实现规则对等**
我们构建 Python 服务的核心，其主要目标是成为 Go 引擎的完美镜像。

1.  **项目设置**：
    *   按照之前讨论的方式创建 `weiqi-ai` 目录结构。
    *   初始化 Python 环境并安装 `fastapi`、`uvicorn`、`numpy`。

2.  **在 Python 中实现核心游戏逻辑**：
    *   在 `weiqi-ai/core/` 目录下，创建 `board.py` 和 `game.py`。
    *   用 Python 重新实现 `RULES.md` 中**完全相同**的游戏规则。这包括棋盘表示、着法验证、提子逻辑、自杀检查和**全局同形再现规则**（需要游戏历史记录）。

3.  **集成并通过共享测试套件**：
    *   将 `weiqi-rules-test-suite` 作为子模块添加到 `weiqi-ai`。
    *   在 `weiqi-ai/tests/` 目录下，使用 `pytest` 创建一个测试运行器，其功能与 Go 的版本相同：加载每个 JSON 文件并验证 Python 引擎的行为。

4.  **创建第一个“合法落子” API**：
    *   实现 `POST /v1/ai/move` 端点。
    *   目前，其逻辑很简单：接收棋盘状态，（使用你新建且已通过验证的游戏引擎）找出所有**合法**的落子位置，然后随机返回一个。

5.  **此阶段目标**：Python 游戏引擎也必须 100% 通过共享测试。FastAPI 服务器能够提供一个永远不会下出非法着法的基本 AI。

#### **阶段 3: 集成 - 第一个端到端的 MVP (最小可行产品)**
连接这两个服务，创建一个可工作的、尽管简单的应用程序。

1.  **将 AI 服务 Docker 化**：为 `weiqi-ai` 项目创建一个 `Dockerfile`。
2.  **使用 Docker Compose 进行编排**：更新 `weiqi-go` 根目录下的 `docker-compose.yml` 文件，使其包含并运行 `weiqi-ai` 服务，与 MongoDB 服务并存。
3.  **连接 Go 与 Python**：在 Go 后端，当轮到 AI 下棋时，向 `weiqi-ai` 服务的 `/v1/ai/move` 端点发起一个 HTTP 客户端调用以获取着法。
4.  **此阶段目标**：用户可以通过 Go API 与“随机合法落子 AI”进行一盘完整的对局。系统完全集成。

#### **阶段 4: AI 开发 - 从 MCTS 到计分**
既然基础已经稳固，我们来让 AI 变得智能。

1.  **实现纯 MCTS**：
    *   在 `weiqi-ai/ai/mcts.py` 中，实现蒙特卡洛树搜索（Monte Carlo Tree Search）算法。
    *   此版本将不使用神经网络。对于“走子推演”（playout/simulation）阶段，它将使用核心游戏引擎中的快速“随机合法落子”逻辑。
    *   更新 `/v1/ai/move` 端点，使用 MCTS 代替单个随机着法。AI 的强度将显著提升。

2.  **实现计分 API (`/v1/game/score`)**：
    *   按照之前的设计创建该端点。
    *   计分的初始实现可以使用基于蒙特卡洛的方法（通常称为“基于模拟的计分”）。从终局棋盘状态开始，随机模拟数百盘棋局。在这些随机棋局结束时，被某一方更频繁拥有的地域被认为是该方的领土。在神经网络可用之前，这是一个出奇有效的起点。
    *   当一局游戏结束时（双方连续虚手），Go 后端将调用此端点。

3.  **此阶段目标**：AI 现在是一个有实力的对手，并且系统能根据中国规则自动为结束的棋局计分。

#### **阶段 5: 高级 AI - 强化学习循环**
这是构建顶级 AI 的最终、长期目标。

1.  **神经网络实现**：在 `weiqi-ai/ai/network.py` 中，使用 PyTorch 或 TensorFlow 定义神经网络架构（例如，一个带有策略头和价值头的类 ResNet 主体结构）。
2.  **自我对弈与训练脚本**：在 `weiqi-ai/training/` 目录下，创建用于自我对弈（使用当前最佳的 MCTS+NN 模型生成游戏数据）和训练（使用这些数据训练下一版网络）的脚本。
3.  **将神经网络与 MCTS 集成**：升级 MCTS 算法，使用神经网络的策略头来指导其搜索，并使用价值头来评估棋盘位置，从而取代随机模拟。
4.  **部署训练好的模型**：更新 FastAPI 应用程序，加载训练好的模型权重，并使用完整的、由神经网络驱动的 MCTS 来处理 `/v1/ai/move` 和 `/v1/game/score`（价值头直接给出分数预测）。
